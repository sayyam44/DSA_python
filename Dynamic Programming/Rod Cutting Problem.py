# https://www.naukri.com/code360/problems/rod-cutting-problem_800284?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf

# We are given a rod of size ‘N’. It can be cut into pieces. Each length 
# of a piece has a particular price given by the price array. Our task is to 
# find the maximum revenue that can be generated by selling the rod after 
# cutting( if required) into pieces.

#We will try to pick lengths and make them equal to the given N (N->Target)

# Recursion
def f(ind,target,price):
    if ind==0:#if we are at index 0 then what would be the price to still make the target
        return target*price[0]
    not_take=0+f(ind-1,target,price)
    take=float('-inf')
    rod_len=ind+1 #as we are doing 0 based indexing
    if (rod_len<=target):
        take=price[ind]+f(ind,target-rod_len,price)
    return max(take,not_take)

def CutRod(price,n):
    return f(len(price)-1,n,price)

price=[2,5,7,8,10]
n=5
print(CutRod(price,n))


# Memoization
def f(ind, target, price, dp):
    # Base case: if the index is 0, the cost to make the target is just the target times the price at index 0
    if ind == 0:
        return target * price[0]
    
    # Check if the result is already computed
    if dp[ind][target] != -1:
        return dp[ind][target]
    
    # Option 1: Don't take the current length
    not_take = f(ind - 1, target, price, dp)
    
    # Option 2: Take the current length if possible
    take = float('-inf')
    rod_len = ind + 1  # Because index is 0-based, rod length is ind + 1
    
    if rod_len <= target:
        take = price[ind] + f(ind, target - rod_len, price, dp)
    
    # Store and return the maximum of the two options
    dp[ind][target] = max(take, not_take)
    return dp[ind][target]

def CutRod(price, n):
    # Initialize the memoization table with -1
    dp = [[-1 for _ in range(n + 1)] for _ in range(len(price))]
    return f(len(price) - 1, n, price, dp)

# Example usage
price = [2, 5, 7, 8, 10]
n = 5
print(CutRod(price, n))  # Output should be the maximum profit



#Tabulation
def CutRod(price, n):
    # Initialize the memoization table with -1
    dp = [[0 for _ in range(n + 1)] for _ in range(len(price))]

    for i in range(n+1):
        dp[0][i] = i*price[0]

    for ind in range(1,len(price)):
        for N in range(n+1):
            not_take=0+dp[ind-1][N]
            take=float('-inf')
            rod_len=ind+1 #as we are doing 0 based indexing
            if (rod_len<=N):
                take=price[ind]+dp[ind-1][N-rod_len]
            dp[ind][N] = max(take, not_take)

    return dp[len(price)-1][n]


price = [2, 5, 7, 8, 10]
n = 5
print(CutRod(price, n))